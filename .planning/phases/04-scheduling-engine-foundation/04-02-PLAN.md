---
phase: 04-scheduling-engine-foundation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - flowplan/src/hooks/use-scheduling.ts
  - flowplan/src/services/tasks.ts
  - flowplan/src/hooks/use-tasks.ts
  - flowplan/src/hooks/use-dependencies.ts
  - flowplan/src/app/page.tsx
autonomous: true

must_haves:
  truths:
    - "When a task's duration changes, all downstream successor dates recalculate automatically"
    - "When a dependency is added/removed/modified, all affected task dates recalculate automatically"
    - "Changed CPM fields (ES/EF/LS/LF/slack/is_critical) are persisted to the database in batch"
    - "start_date and end_date are synced with es/ef for auto-scheduled tasks during batch persist"
    - "No infinite cascade loop occurs -- scheduling is triggered by explicit mutation, not reactive useEffect"
  artifacts:
    - path: "flowplan/src/hooks/use-scheduling.ts"
      provides: "Scheduling orchestration hook"
      exports: ["useScheduling"]
    - path: "flowplan/src/services/tasks.ts"
      provides: "batchUpdateTaskCPMFields function for batch persistence"
      contains: "batchUpdateTaskCPMFields"
  key_links:
    - from: "flowplan/src/hooks/use-scheduling.ts"
      to: "flowplan/src/services/scheduling.ts"
      via: "schedulingService.calculateCriticalPath()"
      pattern: "calculateCriticalPath"
    - from: "flowplan/src/hooks/use-scheduling.ts"
      to: "flowplan/src/services/tasks.ts"
      via: "batchUpdateTaskCPMFields()"
      pattern: "batchUpdateTaskCPMFields"
    - from: "flowplan/src/app/page.tsx"
      to: "flowplan/src/hooks/use-scheduling.ts"
      via: "useScheduling hook"
      pattern: "useScheduling"
---

<objective>
Create the useScheduling hook that orchestrates CPM recalculation, batch persistence, and React Query cache updates. Wire it into the existing mutation flows so that task and dependency changes trigger automatic rescheduling. This is the bridge between the corrected engine (Plan 01) and the UI.

Purpose: Without this wiring, the scheduling engine is disconnected from user actions. This plan makes dates cascade automatically on every scheduling-relevant change (SCHED-01, SCHED-02, SCHED-08).
Output: A useScheduling hook consumed by page.tsx that triggers recalculation on task/dependency mutations and batch-persists results.
</objective>

<execution_context>
@C:/Users/User/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/User/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-scheduling-engine-foundation/04-RESEARCH.md
@.planning/phases/04-scheduling-engine-foundation/04-01-SUMMARY.md

@flowplan/src/services/scheduling.ts
@flowplan/src/services/tasks.ts
@flowplan/src/hooks/use-tasks.ts
@flowplan/src/hooks/use-dependencies.ts
@flowplan/src/hooks/use-calendar-exceptions.ts
@flowplan/src/hooks/use-projects.ts
@flowplan/src/types/entities.ts
@flowplan/src/app/page.tsx
@flowplan/src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add batchUpdateTaskCPMFields to tasks service and create useScheduling hook</name>
  <files>
    flowplan/src/services/tasks.ts
    flowplan/src/hooks/use-scheduling.ts
  </files>
  <action>
**1. Add batch persist function to tasks.ts:**

Add a new exported function `batchUpdateTaskCPMFields` at the bottom of `flowplan/src/services/tasks.ts`:

```typescript
export async function batchUpdateTaskCPMFields(tasks: Task[]): Promise<ServiceResult<void>> {
  if (tasks.length === 0) return { data: null, error: null }

  const updates = tasks.map(task => ({
    id: task.id,
    es: task.es ? (task.es instanceof Date ? task.es.toISOString().split('T')[0] : task.es) : null,
    ef: task.ef ? (task.ef instanceof Date ? task.ef.toISOString().split('T')[0] : task.ef) : null,
    ls: task.ls ? (task.ls instanceof Date ? task.ls.toISOString().split('T')[0] : task.ls) : null,
    lf: task.lf ? (task.lf instanceof Date ? task.lf.toISOString().split('T')[0] : task.lf) : null,
    slack: task.slack ?? 0,
    is_critical: task.is_critical ?? false,
    start_date: task.es ? (task.es instanceof Date ? task.es.toISOString().split('T')[0] : task.es) : null,
    end_date: task.ef ? (task.ef instanceof Date ? task.ef.toISOString().split('T')[0] : task.ef) : null,
  }))

  const { error } = await supabase
    .from('tasks')
    .upsert(updates, { onConflict: 'id' })

  if (error) {
    return { data: null, error: { message: error.message, code: error.code } }
  }

  return { data: null, error: null }
}
```

Note: `start_date` and `end_date` are synced with `es`/`ef` for auto-scheduled tasks per research recommendation. This ensures the Gantt chart (which reads start_date/end_date) shows correct CPM-computed dates.

**2. Create useScheduling hook:**

Create new file `flowplan/src/hooks/use-scheduling.ts`. This hook:

- Gathers all scheduling-relevant data (tasks, dependencies, project, calendar exceptions) via existing hooks
- Provides a `recalculate` function that runs the CPM engine synchronously, updates React Query cache optimistically, then batch-persists to DB
- Exposes the `recalculate` function for consumption by mutation wrappers
- Uses the one-shot mutation pattern (NOT reactive useEffect) to prevent infinite loops

Implementation:

```typescript
import { useCallback, useRef } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { useTasks, taskKeys } from '@/hooks/use-tasks'
import { useDependencies } from '@/hooks/use-dependencies'
import { useCalendarExceptions } from '@/hooks/use-calendar-exceptions'
import { schedulingService } from '@/services/scheduling'
import { batchUpdateTaskCPMFields } from '@/services/tasks'
import type { Task, CalendarException } from '@/types/entities'

function expandCalendarExceptions(exceptions: CalendarException[]): Date[] {
  const dates: Date[] = []
  for (const ex of exceptions) {
    if (ex.type !== 'holiday' && ex.type !== 'non_working') continue
    const start = ex.date instanceof Date ? ex.date : new Date(ex.date)
    dates.push(new Date(start))
    if (ex.end_date) {
      const end = ex.end_date instanceof Date ? ex.end_date : new Date(ex.end_date)
      let current = new Date(start)
      current.setDate(current.getDate() + 1)
      while (current <= end) {
        dates.push(new Date(current))
        current.setDate(current.getDate() + 1)
      }
    }
  }
  return dates
}

export function useScheduling(projectId: string, projectStartDate: Date | string | null) {
  const queryClient = useQueryClient()
  const { data: tasks = [] } = useTasks(projectId)
  const { data: dependencies = [] } = useDependencies(projectId)
  const { data: calendarExceptions = [] } = useCalendarExceptions(projectId)
  const persistRef = useRef<AbortController | null>(null)

  const workDays = [0, 1, 2, 3, 4] // Sun-Thu (Israeli calendar)
  const holidays = expandCalendarExceptions(calendarExceptions)

  const recalculate = useCallback(async (updatedTasks?: Task[]) => {
    const currentTasks = updatedTasks || tasks
    if (currentTasks.length === 0 || !projectStartDate) return

    const projectStart = projectStartDate instanceof Date
      ? projectStartDate
      : new Date(projectStartDate)

    // 1. Compute synchronously (fast, deterministic)
    const result = schedulingService.calculateCriticalPath(
      currentTasks,
      dependencies,
      projectStart,
      workDays,
      holidays
    )

    // 2. Optimistic update: put recalculated tasks into React Query cache immediately
    // This produces a new array reference, which triggers GanttChart re-render
    queryClient.setQueryData(
      taskKeys.list(projectId),
      result.tasks
    )

    // 3. Cancel any in-flight batch persist (serial queue: newest wins)
    if (persistRef.current) {
      persistRef.current.abort()
    }
    const controller = new AbortController()
    persistRef.current = controller

    // 4. Batch persist to DB in background
    try {
      if (!controller.signal.aborted) {
        await batchUpdateTaskCPMFields(result.tasks)
      }
    } catch (err) {
      // If aborted by a newer recalculation, ignore the error
      if (controller.signal.aborted) return
      // Log real errors but don't throw -- optimistic update already applied
      console.error('Failed to persist CPM fields:', err)
    }
  }, [tasks, dependencies, projectStartDate, calendarExceptions, projectId, queryClient, workDays, holidays])

  return {
    recalculate,
    tasks,
    dependencies,
    criticalPath: tasks.filter(t => t.is_critical).map(t => t.id),
  }
}
```

Key design decisions:
- `recalculate` accepts optional `updatedTasks` to avoid stale data from closures (research Pitfall 2)
- AbortController-based serial queue prevents race conditions (research Pitfall 5)
- No useEffect watching task data -- one-shot pattern only (research Pitfall 1, Pattern 3)
- Calendar exceptions are expanded from date ranges into individual dates
- `workDays` is hardcoded to Israeli calendar [0,1,2,3,4] -- matching existing convention
  </action>
  <verify>Run `cd flowplan && npx tsc --noEmit 2>&1 | head -30` to confirm no type errors. Verify use-scheduling.ts exports useScheduling. Verify batchUpdateTaskCPMFields exists in tasks.ts.</verify>
  <done>useScheduling hook exists at flowplan/src/hooks/use-scheduling.ts, exports useScheduling function. batchUpdateTaskCPMFields exists in tasks.ts. Both compile without type errors.</done>
</task>

<task type="auto">
  <name>Task 2: Wire useScheduling into page.tsx mutation flows</name>
  <files>
    flowplan/src/app/page.tsx
    flowplan/src/hooks/use-tasks.ts
    flowplan/src/hooks/use-dependencies.ts
  </files>
  <action>
Wire the useScheduling hook into the main page so that task and dependency mutations trigger automatic rescheduling. The goal: when a user changes duration, adds/removes a dependency, or modifies a dependency type/lag, the schedule recalculates immediately and silently (per locked decision: no toast, no animation).

**Changes to page.tsx:**

1. Import `useScheduling` from `@/hooks/use-scheduling`.
2. In the main component, call `useScheduling(selectedProjectId, project?.start_date)` to get `{ recalculate }`.
3. Find all places where task mutations happen that affect scheduling (duration change, task create, task delete, task status change). After each successful mutation, call `recalculate()`. This must be a one-shot call in the mutation's onSuccess/then handler, NOT a useEffect.
4. Find all places where dependency mutations happen (create, update, delete). After each successful mutation, call `recalculate()`.

The pattern is:
```typescript
// In handleTaskUpdate or wherever updateTask is called:
const handleTaskUpdate = async (taskId: string, updates: UpdateTaskInput) => {
  await updateTask.mutateAsync({ id: taskId, updates })
  // One-shot recalculate after mutation succeeds
  await recalculate()
}
```

**CRITICAL: Do NOT add a useEffect that watches tasks or dependencies and calls recalculate. That creates an infinite loop.** The recalculation must only happen as a direct consequence of an explicit user action (mutation completion).

Look for these mutation call sites in page.tsx and wire recalculate() after each:
- Task creation (handleCreateTask or similar)
- Task update (handleUpdateTask, handleDurationChange, handleStatusChange, etc.)
- Task deletion (handleDeleteTask)
- Dependency creation (handleCreateDependency or similar)
- Dependency update (handleUpdateDependency)
- Dependency deletion (handleDeleteDependency)

If the mutations are already using `.mutateAsync()` followed by other logic, add `await recalculate()` after the mutation succeeds. If using `.mutate()` with onSuccess callbacks, add recalculate() to the onSuccess.

Also update the GanttChart call in page.tsx: change `dependencies={[]}` (line ~933) to pass the real dependencies array from the hook. Read the current value of `dependencies` from `useScheduling` or from `useDependencies`.

**Changes to use-tasks.ts and use-dependencies.ts:**

No structural changes needed. The existing mutation hooks invalidate queries on success, which is fine. The recalculate() call in page.tsx happens AFTER the mutation, using the latest data. If there's concern about stale data in the recalculate closure, the hook's recalculate function reads from React Query cache (latest).

However, there is a subtlety: after `updateTask.mutateAsync()`, the cache invalidation hasn't completed yet. The `recalculate()` call needs fresh task data. To handle this, modify the `recalculate` call to pass the freshly mutated tasks:

Option A (preferred): After mutation, read fresh tasks from cache via `queryClient.getQueryData(taskKeys.list(projectId))`, apply the mutation's result to get the full updated list, and pass to `recalculate(updatedTasks)`.

Option B (simpler, slightly delayed): After mutation, `await queryClient.invalidateQueries({ queryKey: taskKeys.list(projectId) })` to force refetch, THEN call recalculate. This adds a network round-trip but guarantees fresh data.

Use Option A: after a task mutation succeeds, merge the returned task into the current tasks array and pass to recalculate:

```typescript
const handleTaskUpdate = async (taskId: string, updates: UpdateTaskInput) => {
  const updatedTask = await updateTask.mutateAsync({ id: taskId, updates })
  // Merge updated task into current tasks for immediate recalculation
  const currentTasks = tasks.map(t => t.id === updatedTask.id ? updatedTask : t)
  await recalculate(currentTasks)
}
```

For dependency mutations, no merge is needed because dependencies are read from the hook's closure (which is fine since the dependency mutation doesn't change tasks -- it just means the recalculation uses the latest tasks + the invalidated deps).

Actually, dependency changes are trickier. After `createDependency.mutateAsync()`, the dependencies cache hasn't been updated yet. The recalculate function reads `dependencies` from its closure. To fix this: after a dependency mutation, invalidate the dependencies query and wait for it, THEN call recalculate:

```typescript
const handleCreateDependency = async (input: CreateDependencyInput) => {
  await createDependency.mutateAsync(input)
  // Wait for dependencies cache to refresh
  await queryClient.invalidateQueries({ queryKey: dependencyKeys.list(projectId) })
  // Now recalculate with fresh deps
  await recalculate()
}
```

This adds one network call but ensures correct data. The user won't notice because it's fast.
  </action>
  <verify>Run `cd flowplan && npx tsc --noEmit 2>&1 | head -30` to confirm no type errors. Verify page.tsx no longer passes `dependencies={[]}` to GanttChart. Verify recalculate() is called after task and dependency mutations. Verify NO useEffect calls recalculate.</verify>
  <done>page.tsx imports and uses useScheduling. GanttChart receives real dependencies (not empty array). All task mutation handlers (create, update, delete) call recalculate() after success. All dependency mutation handlers (create, update, delete) call recalculate() after success. No reactive useEffect triggers recalculation. The app compiles without type errors.</done>
</task>

</tasks>

<verification>
```bash
cd flowplan && npx tsc --noEmit
cd flowplan && npx vitest run src/services/scheduling.test.ts
```
Type-check passes. All scheduling tests still pass. No infinite loop patterns (grep for `useEffect.*recalculate` should return nothing).
</verification>

<success_criteria>
- useScheduling hook exists and is used in page.tsx
- batchUpdateTaskCPMFields persists CPM fields + syncs start_date/end_date with es/ef
- Task duration/status changes trigger recalculation
- Dependency create/update/delete triggers recalculation
- Recalculation uses one-shot pattern (no useEffect loop)
- GanttChart receives real dependency data (not empty array)
- Race condition handled via AbortController serial queue
- App compiles with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-scheduling-engine-foundation/04-02-SUMMARY.md`
</output>
