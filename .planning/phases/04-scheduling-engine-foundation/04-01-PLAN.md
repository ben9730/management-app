---
phase: 04-scheduling-engine-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - flowplan/src/services/scheduling.ts
  - flowplan/src/services/scheduling.test.ts
autonomous: true

must_haves:
  truths:
    - "SS dependency aligns successor start to predecessor start (plus lag)"
    - "FF dependency aligns successor finish to predecessor finish (plus lag)"
    - "SF dependency constrains successor finish based on predecessor start (plus lag)"
    - "Negative lag (lead time) causes successor to start before predecessor finishes"
    - "All dependency types work correctly in both forward and backward pass"
    - "Multiple predecessors with mixed dependency types resolve to correct dates"
  artifacts:
    - path: "flowplan/src/services/scheduling.ts"
      provides: "CPM engine with all 4 dependency types + lead/lag"
      contains: "case 'SS':"
    - path: "flowplan/src/services/scheduling.test.ts"
      provides: "Tests for SS/FF/SF dependency types and negative lag"
      contains: "SS dependency"
  key_links:
    - from: "flowplan/src/services/scheduling.ts"
      to: "types/entities.ts"
      via: "DependencyType enum"
      pattern: "dep\\.type"
---

<objective>
Fix the CPM scheduling engine to correctly compute dates for all 4 dependency types (FS/SS/FF/SF) with lead/lag support (including negative lag). Currently the engine treats ALL dependency types as FS -- the forward pass only uses predecessor EF and the backward pass only uses successor LS.

Purpose: This is the algorithmic foundation for the entire phase. Without correct formulas, wiring the engine to the UI would produce wrong dates.
Output: A scheduling engine that correctly computes ES/EF/LS/LF for FS, SS, FF, and SF dependency types with positive and negative lag.
</objective>

<execution_context>
@C:/Users/User/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/User/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-scheduling-engine-foundation/04-RESEARCH.md

@flowplan/src/services/scheduling.ts
@flowplan/src/services/scheduling.test.ts
@flowplan/src/types/entities.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for SS/FF/SF dependency types and negative lag</name>
  <files>flowplan/src/services/scheduling.test.ts</files>
  <action>
Add new test blocks to the existing scheduling.test.ts file. Use the existing `createMockTask` and `createMockDependency` helpers. All tests should use the Israeli work week (Sun-Thu = [0,1,2,3,4]) and project start of 2026-01-25 (Sunday).

Add these test groups:

1. **Forward Pass - SS dependencies:**
   - Test: Two tasks (A duration 3, B duration 2) with SS dependency. B's ES should equal A's ES (2026-01-25).
   - Test: SS with +2 lag. B's ES should be A's ES + 2 working days.
   - Test: SS with -1 lag (lead). B's ES should be 1 working day before A's ES, clamped to project start.

2. **Forward Pass - FF dependencies:**
   - Test: Two tasks (A duration 5, B duration 3) with FF dependency. B's EF should equal A's EF. Since B's duration is 3, B's ES = A's EF - 3 + 1 working days.
   - Test: FF with +1 lag. B's EF should be A's EF + 1 working day.

3. **Forward Pass - SF dependencies:**
   - Test: Two tasks (A duration 3, B duration 2) with SF dependency. B's EF should align to A's ES. B's ES = A's ES - B's duration + 1 working days.

4. **Forward Pass - Negative lag (lead time):**
   - Test: FS with -2 lag. Successor starts 2 working days before predecessor finishes.
   - Test: Negative lag that would push before project start should clamp to project start.

5. **Backward Pass - SS/FF/SF:**
   - Test: SS backward pass -- predecessor LF is derived from successor LS minus lag, plus predecessor duration.
   - Test: FF backward pass -- predecessor LF equals successor LF minus lag.
   - Test: SF backward pass -- predecessor LS is derived from successor LF minus lag.

6. **Mixed dependency types on one successor:**
   - Test: Task C depends on A (FS) and B (SS). C's ES = max(A's EF+1, B's ES). Verify correct resolution.

7. **Full calculateCriticalPath with non-FS deps:**
   - Test: A chain using SS and FF deps. Verify slack and critical path are computed correctly end-to-end.

Run `npx vitest run src/services/scheduling.test.ts` -- all NEW tests MUST FAIL (RED phase). Existing tests must still pass.
  </action>
  <verify>Run `cd flowplan && npx vitest run src/services/scheduling.test.ts 2>&1`. New tests fail (expected). Existing tests pass. Test file parses without syntax errors.</verify>
  <done>At least 10 new test cases covering SS, FF, SF forward pass; negative lag; backward pass for all types; mixed types; and full CPM with non-FS deps. All new tests fail because the engine treats all deps as FS.</done>
</task>

<task type="auto">
  <name>Task 2: Fix forward and backward pass to handle all dependency types with lead/lag</name>
  <files>flowplan/src/services/scheduling.ts</files>
  <action>
Rewrite the `forwardPass` and `backwardPass` methods in SchedulingService to handle all 4 dependency types. Also update `calculateWithResources` which has a duplicated forward pass that also treats all deps as FS.

**Forward Pass changes (forwardPass method):**

Replace the inner loop that currently does `candidateDate = this.addDays(predTask.ef, 1)` for all deps. Instead, use a switch on `dep.type`:

- **FS:** candidateES = predEF + 1 day + lag (existing behavior, keep it)
- **SS:** candidateES = predES + lag (start-to-start: successor starts when predecessor starts)
- **FF:** candidateEF_constraint = predEF + lag. Then candidateES = subtractWorkingDays(candidateEF_constraint, task.duration). FF constrains the successor's FINISH, so we back-compute ES from the finish constraint.
- **SF:** candidateEF_constraint = predES + lag. Then candidateES = subtractWorkingDays(candidateEF_constraint, task.duration). SF constrains successor's FINISH based on predecessor's START.

For negative lag (lead time): when `dep.lag_days < 0`, use `subtractWorkingDays` instead of `addWorkingDays`. After computing candidateES, clamp it: if candidateES < projectStart, set candidateES = findNextWorkingDay(projectStart).

Final ES = max(all candidateES values). EF = addWorkingDays(ES, task.duration).

**Backward Pass changes (backwardPass method):**

Replace the inner loop that currently does `candidateDate = this.addDays(succTask.ls, -1)` for all deps. Instead, use a switch on `dep.type`:

- **FS:** candidateLF = succLS - 1 - lag (existing behavior)
- **SS:** SS constrains successor LS, so predecessor LS = succLS - lag. Predecessor candidateLF = addWorkingDays(constrainedLS, task.duration). This is different from FS -- SS constrains the LS relationship, so we derive LF from the constrained LS + duration.
- **FF:** candidateLF = succLF - lag (finish-to-finish: predecessor LF derived from successor LF)
- **SF:** SF constrains successor LF based on predecessor LS. Predecessor LS = succLF - lag. candidateLF = addWorkingDays(constrainedLS, task.duration).

For negative lag in backward pass: when `dep.lag_days < 0`, swap add/subtract directions (subtracting a negative = adding).

Final LF = min(all candidateLF values). LS = subtractWorkingDays(LF, task.duration).

**calculateWithResources changes:**

The resource-aware forward pass (lines ~569-606) has its own duplicated loop that also treats all deps as FS. Apply the same 4-type switch logic there. The only difference is it uses `memberWorkDays` and `allHolidays` instead of project-level work days.

**Important implementation notes:**
- Keep the helper methods (addDays, addWorkingDays, subtractWorkingDays, etc.) -- they are correct and reusable.
- Make addDays and findNextWorkingDay/findPreviousWorkingDay public (currently private) so tests can verify intermediate results if needed. Actually, keep them private -- tests should verify through the public API (forwardPass, backwardPass, calculateCriticalPath).
- Do NOT change the topologicalSort or calculateSlack methods -- they are dependency-type agnostic and already correct.
- Maintain immutability: clone tasks with spread operator before modifying (already done).
  </action>
  <verify>Run `cd flowplan && npx vitest run src/services/scheduling.test.ts 2>&1`. ALL tests pass (both old and new). Zero failures.</verify>
  <done>All existing FS tests still pass. All new SS/FF/SF/negative-lag tests pass. The forward pass, backward pass, and calculateWithResources all handle FS/SS/FF/SF with positive and negative lag correctly.</done>
</task>

</tasks>

<verification>
```bash
cd flowplan && npx vitest run src/services/scheduling.test.ts
```
All tests pass. No regressions in existing FS behavior. New SS/FF/SF and negative lag tests demonstrate correct formula implementation.
</verification>

<success_criteria>
- All 4 dependency types (FS, SS, FF, SF) compute correct ES/EF in forward pass
- All 4 dependency types compute correct LS/LF in backward pass
- Negative lag (lead time) works for all dependency types
- Negative lag clamps to project start (does not produce dates before project start)
- Mixed dependency types on a single successor resolve correctly (max of all candidate ES values)
- Full calculateCriticalPath produces correct slack and critical path for non-FS dependency chains
- calculateWithResources also supports all 4 dependency types
- All existing tests continue to pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/04-scheduling-engine-foundation/04-01-SUMMARY.md`
</output>
