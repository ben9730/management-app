---
phase: 04-scheduling-engine-foundation
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - flowplan/src/components/gantt/GanttChart.tsx
autonomous: false

must_haves:
  truths:
    - "Dependency lines connect correct anchor points based on type (FS: end-to-start, SS: start-to-start, FF: end-to-end, SF: start-to-end)"
    - "All dependency types use the same line style (no color/dash differentiation) per user decision"
    - "Hovering a dependency line shows a tooltip with type and lag (e.g., 'FS +2d')"
    - "Lead/lag values shown in hover tooltip only (not as permanent label) per user decision"
    - "Gantt chart reflects new dates and critical path after any scheduling change without manual refresh"
  artifacts:
    - path: "flowplan/src/components/gantt/GanttChart.tsx"
      provides: "Dependency-type-aware line rendering with hover tooltips"
      contains: "case 'SS':"
  key_links:
    - from: "flowplan/src/components/gantt/GanttChart.tsx"
      to: "flowplan/src/types/entities.ts"
      via: "Dependency.type field"
      pattern: "dep\\.type"
    - from: "flowplan/src/components/gantt/GanttChart.tsx"
      to: "flowplan/src/hooks/use-scheduling.ts"
      via: "receives tasks and dependencies props from page.tsx which uses useScheduling"
      pattern: "dependencies"
---

<objective>
Update the GanttChart component to render dependency lines with type-aware anchor points (FS/SS/FF/SF connect to the correct sides of task bars) and add hover tooltips showing dependency type and lag. Currently the dependency rendering always uses end-to-start anchor points regardless of type.

Purpose: This completes the visual feedback loop -- users can see dependency relationships correctly represented in the Gantt chart, and hovering reveals the type and lag. Satisfies SCHED-07 (Gantt reflects changes immediately) and the locked decision on dependency display.
Output: GanttChart renders all dependency types with correct anchor points and hover tooltips.
</objective>

<execution_context>
@C:/Users/User/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/User/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-scheduling-engine-foundation/04-RESEARCH.md
@.planning/phases/04-scheduling-engine-foundation/04-02-SUMMARY.md

@flowplan/src/components/gantt/GanttChart.tsx
@flowplan/src/types/entities.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependency-type-aware line rendering with anchor points</name>
  <files>flowplan/src/components/gantt/GanttChart.tsx</files>
  <action>
Update the dependency rendering SVG section in GanttChart.tsx. Currently all dependency lines connect from predecessor's right edge (end) to successor's left edge (start) -- this is correct for FS but wrong for SS/FF/SF.

**Add a helper function inside the component file (above GanttChartComponent):**

```typescript
function getDependencyEndpoints(
  depType: DependencyType,
  predPos: TaskPosition,
  succPos: TaskPosition,
  rowHeight: number
): { startX: number; startY: number; endX: number; endY: number } {
  const predBarHeight = rowHeight - 12
  const predCenterY = predPos.top + 6 + predBarHeight / 2
  const succCenterY = succPos.top + 6 + predBarHeight / 2

  // Use Math.max to ensure minimum bar width is accounted for
  const predRight = predPos.left + Math.max(predPos.width, MIN_BAR_WIDTH)
  const succRight = succPos.left + Math.max(succPos.width, MIN_BAR_WIDTH)

  switch (depType) {
    case 'FS':
      // Finish-to-Start: predecessor END -> successor START
      return { startX: predRight, startY: predCenterY, endX: succPos.left, endY: succCenterY }
    case 'SS':
      // Start-to-Start: predecessor START -> successor START
      return { startX: predPos.left, startY: predCenterY, endX: succPos.left, endY: succCenterY }
    case 'FF':
      // Finish-to-Finish: predecessor END -> successor END
      return { startX: predRight, startY: predCenterY, endX: succRight, endY: succCenterY }
    case 'SF':
      // Start-to-Finish: predecessor START -> successor END
      return { startX: predPos.left, startY: predCenterY, endX: succRight, endY: succCenterY }
    default:
      // Fallback to FS
      return { startX: predRight, startY: predCenterY, endX: succPos.left, endY: succCenterY }
  }
}
```

Import `DependencyType` from `@/types/entities` (add to the existing import).

**Update the SVG dependency rendering section** (currently around lines 517-561). Replace the hardcoded FS endpoint calculation with the helper:

```tsx
{dependencies.map((dep) => {
  const predecessorPos = taskPositions.find((p) => p.task.id === dep.predecessor_id)
  const successorPos = taskPositions.find((p) => p.task.id === dep.successor_id)
  if (!predecessorPos || !successorPos) return null

  const { startX, startY, endX, endY } = getDependencyEndpoints(
    dep.type, predecessorPos, successorPos, ROW_HEIGHT
  )

  // Adaptive curve: adjust control points based on direction
  const dx = endX - startX
  const curveOffset = Math.max(15, Math.abs(dx) * 0.3)

  const path = `M ${startX} ${startY} C ${startX + curveOffset} ${startY}, ${endX - curveOffset} ${endY}, ${endX} ${endY}`

  return (
    <g key={dep.id} data-testid={`dependency-${dep.id}`}>
      <path
        d={path}
        fill="none"
        stroke={hoveredDepId === dep.id ? 'var(--fp-brand-primary)' : 'var(--fp-border-medium)'}
        strokeWidth={hoveredDepId === dep.id ? 2 : 1.5}
        markerEnd="url(#arrowhead)"
        strokeDasharray="4 2"
      />
      {/* Invisible wider path for easier hover detection */}
      <path
        d={path}
        fill="none"
        stroke="transparent"
        strokeWidth="12"
        className="cursor-pointer"
        style={{ pointerEvents: 'stroke' }}
        onMouseEnter={(e) => {
          setHoveredDepId(dep.id)
          const rect = (e.currentTarget.ownerSVGElement?.closest('[data-testid="gantt-chart"]') as HTMLElement)?.getBoundingClientRect()
          if (rect) {
            setHoveredDepPos({ x: e.clientX - rect.left, y: e.clientY - rect.top })
          }
        }}
        onMouseMove={(e) => {
          const rect = (e.currentTarget.ownerSVGElement?.closest('[data-testid="gantt-chart"]') as HTMLElement)?.getBoundingClientRect()
          if (rect) {
            setHoveredDepPos({ x: e.clientX - rect.left, y: e.clientY - rect.top })
          }
        }}
        onMouseLeave={() => {
          setHoveredDepId(null)
          setHoveredDepPos(null)
        }}
      />
    </g>
  )
})}
```

Note: Per locked decision, ALL dependency types use the same line style (stroke color, dash pattern). No differentiation by color or dash style. The hover highlight is transient only.

Also add the state variables inside GanttChartComponent alongside existing `hoveredTaskId`:
```typescript
const [hoveredDepId, setHoveredDepId] = React.useState<string | null>(null)
const [hoveredDepPos, setHoveredDepPos] = React.useState<{ x: number; y: number } | null>(null)
```

And add the tooltip helper function:
```typescript
function getDependencyTooltipContent(dep: Dependency): string {
  const lagStr = dep.lag_days !== 0
    ? ` ${dep.lag_days > 0 ? '+' : ''}${dep.lag_days}d`
    : ''
  return `${dep.type}${lagStr}`
}
```

And render the dependency tooltip after the existing task tooltip:
```tsx
{hoveredDepId && hoveredDepPos && (() => {
  const dep = dependencies.find(d => d.id === hoveredDepId)
  if (!dep) return null
  return (
    <div
      data-testid="dependency-tooltip"
      className="absolute z-50 bg-[var(--fp-bg-secondary)] text-[var(--fp-text-primary)] px-3 py-1.5 text-sm border border-[var(--fp-border-light)] rounded-lg shadow-xl pointer-events-none font-mono font-bold"
      style={{
        left: hoveredDepPos.x + 12,
        top: hoveredDepPos.y - 20,
      }}
    >
      {getDependencyTooltipContent(dep)}
    </div>
  )
})()}
```
  </action>
  <verify>Run `cd flowplan && npx tsc --noEmit 2>&1 | head -30` to confirm no type errors. Verify getDependencyEndpoints function exists with all 4 cases. Verify dependency-tooltip test-id exists.</verify>
  <done>GanttChart renders dependency lines with correct anchor points per type: FS end-to-start, SS start-to-start, FF end-to-end, SF start-to-end. All lines use identical visual style. Hovering shows tooltip with type and lag (e.g., "FS +2d"). The component compiles without errors.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify end-to-end scheduling cascade in Gantt chart</name>
  <files>flowplan/src/components/gantt/GanttChart.tsx</files>
  <action>
Start the dev server and verify the complete scheduling engine foundation works end-to-end. This checkpoint confirms all 3 plans of Phase 4 work together correctly.

Run: `cd flowplan && npm run dev`
Then verify in browser per the steps below.
  </action>
  <verify>
All 11 verification steps below pass in the browser:
1. Project with start date can be selected/created
2. Tasks can be created and appear in Gantt
3. FS dependency causes successor to start after predecessor finishes
4. Duration change cascades to successors automatically
5. SS dependency aligns starts
6. Hover tooltip shows dependency type
7. Lag values shift dates and show in tooltip
8. Gantt updates immediately (no manual refresh)
9. Dates persist after page refresh
  </verify>
  <done>Human has verified that the scheduling cascade works end-to-end in the browser. All dependency types produce correct visual results. Tooltips show type and lag. Dates cascade and persist.</done>
</task>

</tasks>

<verification>
```bash
cd flowplan && npx tsc --noEmit
cd flowplan && npx vitest run src/services/scheduling.test.ts
cd flowplan && npm run build
```
Type-check passes. All scheduling tests pass. Production build succeeds.

Manual verification: dependency lines connect correct anchor points per type, hover tooltip shows "FS +2d" format, dates cascade on mutation.
</verification>

<success_criteria>
- Dependency lines use correct anchor points: FS=end-to-start, SS=start-to-start, FF=end-to-end, SF=start-to-end
- All dependency lines use identical visual style (no color/dash differentiation) -- locked decision honored
- Hovering a dependency line shows tooltip with type and lag (e.g., "FS +2d") -- locked decision honored
- Lead/lag shown in tooltip only, not as permanent label -- locked decision honored
- Gantt chart re-renders when task dates change via scheduling cascade
- Human verification confirms end-to-end cascade works visually
</success_criteria>

<output>
After completion, create `.planning/phases/04-scheduling-engine-foundation/04-03-SUMMARY.md`
</output>
