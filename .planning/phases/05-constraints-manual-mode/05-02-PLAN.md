---
phase: 05-constraints-manual-mode
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - flowplan/src/services/tasks.ts
  - flowplan/src/hooks/use-scheduling.ts
  - flowplan/src/components/forms/TaskForm.tsx
  - flowplan/src/app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Creating/updating a task with constraint_type and constraint_date persists to database"
    - "Manual task dates are not overwritten by batchUpdateTaskCPMFields during recalculation"
    - "Toast notification fires when MSO constraint is overridden by a dependency"
    - "Toast notification fires when FNLT deadline is violated"
    - "User can select constraint type (ASAP/MSO/SNET/FNLT) in TaskForm"
    - "Constraint date picker appears only when constraint type requires a date (MSO/SNET/FNLT)"
    - "User can toggle manual scheduling mode in TaskForm"
    - "Toggling to manual auto-fills start_date/end_date from current ES/EF"
    - "Constraint fields hidden when manual mode is active"
  artifacts:
    - path: "flowplan/src/services/tasks.ts"
      provides: "CRUD with constraint/manual fields, manual-aware batchUpdateTaskCPMFields"
      contains: "scheduling_mode"
    - path: "flowplan/src/hooks/use-scheduling.ts"
      provides: "Constraint violation detection and toast notifications after recalculation"
      contains: "_constraintOverridden"
    - path: "flowplan/src/components/forms/TaskForm.tsx"
      provides: "Constraint type selector, date picker, manual mode toggle"
      contains: "constraint_type"
    - path: "flowplan/src/app/page.tsx"
      provides: "Passes constraint/manual fields through handleTaskFormSubmit"
      contains: "constraint_type"
  key_links:
    - from: "flowplan/src/components/forms/TaskForm.tsx"
      to: "flowplan/src/app/page.tsx"
      via: "TaskFormData includes constraint_type, constraint_date, scheduling_mode"
      pattern: "constraint_type.*onSubmit"
    - from: "flowplan/src/app/page.tsx"
      to: "flowplan/src/services/tasks.ts"
      via: "handleTaskFormSubmit passes constraint fields to createTask/updateTask"
      pattern: "constraint_type.*createTask|updateTask"
    - from: "flowplan/src/hooks/use-scheduling.ts"
      to: "flowplan/src/services/tasks.ts"
      via: "batchUpdateTaskCPMFields skips manual task dates"
      pattern: "scheduling_mode.*manual"
---

<objective>
Wire constraint and manual mode fields through the service layer, hook, and form UI.

Purpose: The engine (Plan 01) handles constraints/manual mode algorithmically. This plan connects that engine to the data layer (persist fields, skip manual dates in batch update), adds violation detection with toast notifications, and builds the form UI for users to set constraints and toggle manual mode.

Output: Updated task service with constraint/manual fields in CRUD and manual-aware batch update. useScheduling hook with violation detection and toasts. TaskForm with constraint type selector, date picker, and manual mode toggle. page.tsx passing new fields through form submission.
</objective>

<execution_context>
@C:/Users/User/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/User/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-constraints-manual-mode/05-CONTEXT.md
@.planning/phases/05-constraints-manual-mode/05-RESEARCH.md
@.planning/phases/05-constraints-manual-mode/05-01-SUMMARY.md
@flowplan/src/services/tasks.ts
@flowplan/src/hooks/use-scheduling.ts
@flowplan/src/components/forms/TaskForm.tsx
@flowplan/src/app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update task service and useScheduling hook for constraints and manual mode</name>
  <files>
    flowplan/src/services/tasks.ts
    flowplan/src/hooks/use-scheduling.ts
  </files>
  <action>
**1. Update tasks.ts service inputs and CRUD:**

Add to `CreateTaskInput` interface:
```typescript
constraint_type?: string | null    // 'ASAP' | 'MSO' | 'SNET' | 'FNLT' | null
constraint_date?: string | null    // ISO date string
scheduling_mode?: string           // 'auto' | 'manual'
```

Add to `UpdateTaskInput` interface:
```typescript
constraint_type?: string | null
constraint_date?: string | null
scheduling_mode?: string
```

Update `createTask` function's `taskData` object to include the new fields with defaults:
```typescript
constraint_type: input.constraint_type ?? null,
constraint_date: input.constraint_date ?? null,
scheduling_mode: input.scheduling_mode ?? 'auto',
```

The `updateTask` function passes through `updates` spread already, so constraint/manual fields will flow through automatically when included in UpdateTaskInput.

**2. Update `batchUpdateTaskCPMFields` to skip manual task dates:**

Replace the current `.map(task => ...)` logic with manual-task-aware branching:

```typescript
tasks.map(task => {
  if ((task as Record<string, unknown>).scheduling_mode === 'manual') {
    // Manual tasks: update CPM metadata (slack, critical path) but NOT dates
    // User controls start_date/end_date -- engine must not overwrite them
    return supabase
      .from('tasks')
      .update({
        es: toDateStr(task.es),
        ef: toDateStr(task.ef),
        ls: toDateStr(task.ls),
        lf: toDateStr(task.lf),
        slack: task.slack ?? 0,
        is_critical: task.is_critical ?? false,
        // CRITICAL: Do NOT set start_date or end_date for manual tasks
      } as never)
      .eq('id', task.id)
  }
  // Auto tasks: sync start_date/end_date with es/ef as before
  return supabase
    .from('tasks')
    .update({
      es: toDateStr(task.es),
      ef: toDateStr(task.ef),
      ls: toDateStr(task.ls),
      lf: toDateStr(task.lf),
      slack: task.slack ?? 0,
      is_critical: task.is_critical ?? false,
      start_date: toDateStr(task.es),
      end_date: toDateStr(task.ef),
    } as never)
    .eq('id', task.id)
})
```

This is the MOST CRITICAL change -- if manual task dates get overwritten by batch update, the entire manual mode feature breaks (Pitfall 4 from research).

**3. Add constraint violation detection to useScheduling hook:**

After `schedulingService.calculateCriticalPath(...)` returns, add violation detection logic. Import toast from sonner:

```typescript
import { toast } from 'sonner'
```

After the optimistic cache update (step 3 in the current hook), before the background persist (step 4):

```typescript
// Detect and notify constraint violations (fire-and-forget, no state updates)
for (const task of result.tasks) {
  const taskAny = task as Record<string, unknown>

  if (taskAny._constraintOverridden) {
    // Find the driving predecessor for the toast message
    const taskDeps = currentDeps.filter(d => d.successor_id === task.id)
    let drivingPredName = 'משימה קודמת'
    for (const dep of taskDeps) {
      const pred = currentTasks.find(t => t.id === dep.predecessor_id)
      if (pred) {
        drivingPredName = pred.title
        break
      }
    }
    toast.warning('אילוץ הותאם', {
      description: `התלות ב-"${drivingPredName}" דורשת התחלה מאוחרת יותר מתאריך האילוץ של "${task.title}"`,
      duration: 5000,
    })
  }

  if (taskAny._fnltViolation) {
    const constraintDate = task.constraint_date
    const dateStr = constraintDate
      ? (constraintDate instanceof Date ? constraintDate : new Date(constraintDate)).toLocaleDateString('he-IL')
      : ''
    toast.error('אזהרת דדליין', {
      description: `"${task.title}" חורג מהדדליין (${dateStr})`,
      duration: 7000,
    })
  }
}
```

**CRITICAL: Toast calls are fire-and-forget side effects. They must NOT trigger state updates or recalculation (Pitfall 2 from research). No `setState` or cache mutations in this block.**
  </action>
  <verify>
Run `cd flowplan && npx tsc --noEmit` -- TypeScript compiles. Verify that `batchUpdateTaskCPMFields` contains the `scheduling_mode === 'manual'` branch. Verify that `use-scheduling.ts` imports `toast` from `sonner` and contains `_constraintOverridden` check.
  </verify>
  <done>
CreateTaskInput and UpdateTaskInput include constraint/manual fields. batchUpdateTaskCPMFields skips start_date/end_date for manual tasks. useScheduling fires toast notifications for MSO constraint overrides and FNLT deadline violations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add constraint controls and manual toggle to TaskForm, wire through page.tsx</name>
  <files>
    flowplan/src/components/forms/TaskForm.tsx
    flowplan/src/app/page.tsx
  </files>
  <action>
**1. Update TaskFormData interface** in TaskForm.tsx to include new fields:

```typescript
export interface TaskFormData {
  title: string
  description?: string
  priority: TaskPriority
  duration: number
  estimated_hours?: number
  start_date?: string
  phase_id?: string
  assignee_id?: string
  assignee_ids?: string[]
  // Constraint & Manual mode (Phase 5)
  constraint_type?: string | null    // 'ASAP' | 'MSO' | 'SNET' | 'FNLT' | null
  constraint_date?: string | null    // ISO date string for MSO/SNET/FNLT
  scheduling_mode?: string           // 'auto' | 'manual'
}
```

**2. Add constraint type options** (constant, placed near `priorityOptions`):

```typescript
const constraintOptions: SelectOption[] = [
  { value: '', label: 'ללא אילוץ' },      // No constraint (default)
  { value: 'ASAP', label: 'בהקדם האפשרי (ASAP)' },
  { value: 'MSO', label: 'חייב להתחיל ב- (MSO)' },
  { value: 'SNET', label: 'לא לפני (SNET)' },
  { value: 'FNLT', label: 'לסיים לא אחרי (FNLT)' },
]
```

**3. Update form state initialization** to include new fields from `initialValues`:

```typescript
const [constraintType, setConstraintType] = React.useState<string>(
  initialValues?.constraint_type || ''
)
const [constraintDate, setConstraintDate] = React.useState<string>(
  initialValues?.constraint_date || ''
)
const [schedulingMode, setSchedulingMode] = React.useState<string>(
  initialValues?.scheduling_mode || 'auto'
)
```

**4. Add handler for manual mode toggle:**

```typescript
const handleSchedulingModeChange = (isManual: boolean) => {
  const newMode = isManual ? 'manual' : 'auto'
  setSchedulingMode(newMode)
  if (isManual) {
    // Auto-fill start_date from current value or today (Pitfall 3 prevention)
    if (!startDate) {
      setStartDate(new Date().toISOString().split('T')[0])
    }
    // Clear constraint when switching to manual (manual tasks don't use constraints)
    setConstraintType('')
    setConstraintDate('')
  }
}
```

**5. Add handler for constraint type change:**

```typescript
const handleConstraintTypeChange = (value: string) => {
  setConstraintType(value)
  // Clear constraint date when switching to no constraint or ASAP (no date needed)
  if (!value || value === 'ASAP') {
    setConstraintDate('')
  }
}
```

**6. Update form submission** to include new fields in the `data` object passed to `onSubmit`:

```typescript
const data: TaskFormData = {
  // ... existing fields ...
  constraint_type: constraintType || null,
  constraint_date: constraintDate || null,
  scheduling_mode: schedulingMode,
}
```

**7. Add UI section** in the form JSX, after the duration/estimated_hours row and before the assignee section. Use a collapsible section with "Advanced Scheduling" header:

```tsx
{/* Advanced Scheduling Section */}
<div className="space-y-3 border-t border-[var(--fp-border-light)] pt-4 mt-4">
  <div className="flex items-center justify-between">
    <span className="text-xs font-bold uppercase tracking-wider text-slate-500">
      תזמון מתקדם
    </span>
    {/* Manual mode toggle */}
    <label className="flex items-center gap-2 text-sm cursor-pointer select-none">
      <input
        type="checkbox"
        checked={schedulingMode === 'manual'}
        onChange={(e) => handleSchedulingModeChange(e.target.checked)}
        className="rounded border-slate-600 bg-slate-800 text-blue-500 focus:ring-blue-500"
      />
      <span className="text-slate-400">תזמון ידני</span>
    </label>
  </div>

  {/* Constraint fields -- only shown in auto mode */}
  {schedulingMode === 'auto' && (
    <div className="grid grid-cols-2 gap-3">
      <Select
        label="סוג אילוץ"
        options={constraintOptions}
        value={constraintType}
        onChange={handleConstraintTypeChange}
      />
      {(constraintType === 'MSO' || constraintType === 'SNET' || constraintType === 'FNLT') && (
        <Input
          label="תאריך אילוץ"
          type="date"
          value={constraintDate}
          onChange={(e) => setConstraintDate(e.target.value)}
          required
        />
      )}
    </div>
  )}

  {/* Manual mode info text */}
  {schedulingMode === 'manual' && (
    <p className="text-xs text-slate-500">
      המשימה תישמר בתאריכים שנקבעו ידנית ולא תזוז כשמשימות קודמות משתנות.
    </p>
  )}
</div>
```

**8. Update page.tsx `handleTaskFormSubmit`** to pass constraint/manual fields to createTask/updateTask:

Find the `handleTaskFormSubmit` function. In the object passed to `createTask` and `updateTask`, add:

```typescript
constraint_type: formData.constraint_type || null,
constraint_date: formData.constraint_date || null,
scheduling_mode: formData.scheduling_mode || 'auto',
```

Also update the `initialValues` passed to TaskForm when editing a task (the `editingTask` object). Map the task's constraint/manual fields to the form's initialValues:

```typescript
constraint_type: editingTask.constraint_type || '',
constraint_date: editingTask.constraint_date
  ? (editingTask.constraint_date instanceof Date
    ? editingTask.constraint_date.toISOString().split('T')[0]
    : String(editingTask.constraint_date))
  : '',
scheduling_mode: editingTask.scheduling_mode || 'auto',
```

**IMPORTANT: No `end_date` auto-compute for manual mode.** When in manual mode, the user controls both start_date and end_date directly. Do NOT auto-compute end_date from duration -- the user may want to set arbitrary dates. (For auto mode, existing behavior is preserved.)
  </action>
  <verify>
Run `cd flowplan && npx tsc --noEmit` -- TypeScript compiles. Run `cd flowplan && npm run build` -- build succeeds. Verify TaskForm.tsx contains "תזמון מתקדם" section. Verify page.tsx contains `constraint_type` in handleTaskFormSubmit.
  </verify>
  <done>
TaskForm shows constraint type dropdown (ASAP/MSO/SNET/FNLT), conditional date picker for MSO/SNET/FNLT, and manual mode toggle. Constraint fields hidden when manual mode active. Manual mode auto-fills start_date on toggle. page.tsx passes constraint/manual fields to createTask/updateTask. Form correctly populates when editing an existing task with constraints.
  </done>
</task>

</tasks>

<verification>
1. `cd flowplan && npm run build` -- Full build succeeds
2. `cd flowplan && npx vitest run src/services/scheduling.test.ts` -- All tests pass
3. tasks.ts CreateTaskInput includes constraint_type, constraint_date, scheduling_mode
4. batchUpdateTaskCPMFields has manual task branch (does not overwrite start_date/end_date)
5. use-scheduling.ts fires toasts for constraint violations
6. TaskForm.tsx has constraint type Select, constraint date Input, manual mode checkbox
7. page.tsx passes constraint/manual fields through handleTaskFormSubmit
</verification>

<success_criteria>
- Build succeeds without TypeScript errors
- Manual task dates NOT overwritten by batchUpdateTaskCPMFields (verified by code inspection)
- Toast fires for MSO constraint override (Hebrew message with predecessor name)
- Toast fires for FNLT deadline violation (Hebrew message with deadline date)
- TaskForm: constraint type dropdown with 5 options (none, ASAP, MSO, SNET, FNLT)
- TaskForm: date picker appears only for MSO/SNET/FNLT
- TaskForm: manual toggle hides constraint fields and shows info text
- page.tsx: constraint/manual fields flow through createTask and updateTask
</success_criteria>

<output>
After completion, create `.planning/phases/05-constraints-manual-mode/05-02-SUMMARY.md`
</output>
