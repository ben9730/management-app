---
phase: 01-phase-lock-logic
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - flowplan/src/types/entities.ts
  - flowplan/src/services/phase-lock.ts
  - flowplan/src/services/phase-lock.test.ts
  - flowplan/src/hooks/use-phase-lock-status.ts
  - flowplan/src/hooks/use-phase-lock-status.test.ts
autonomous: true
must_haves:
  truths:
    - "Given a project with multiple phases, the system returns correct lock/unlock status for every phase based on prior phase task completion"
    - "The first phase in any project is always reported as unlocked regardless of any other state"
    - "When the last incomplete task in a phase is marked complete, the next phase transitions from locked to unlocked without page reload"
    - "Empty phases (zero tasks) do not block subsequent phases"
    - "Tasks with null phase_id do not affect phase lock calculations"
  artifacts:
    - path: "flowplan/src/services/phase-lock.ts"
      provides: "Pure computation of phase lock status from phases and tasks arrays"
      exports: ["computePhaseLockStatus", "isPhaseLocked", "PhaseLockInfo"]
    - path: "flowplan/src/services/phase-lock.test.ts"
      provides: "Comprehensive unit tests for phase lock service"
      contains: "describe.*computePhaseLockStatus"
      min_lines: 80
    - path: "flowplan/src/hooks/use-phase-lock-status.ts"
      provides: "React hook that derives lock status from usePhases + useTasks via useMemo"
      exports: ["usePhaseLockStatus"]
    - path: "flowplan/src/hooks/use-phase-lock-status.test.ts"
      provides: "Hook tests verifying derived state from mocked service data"
      contains: "describe.*usePhaseLockStatus"
    - path: "flowplan/src/types/entities.ts"
      provides: "PhaseLockInfo interface added to existing entity types"
      contains: "interface PhaseLockInfo"
  key_links:
    - from: "flowplan/src/hooks/use-phase-lock-status.ts"
      to: "flowplan/src/services/phase-lock.ts"
      via: "import { computePhaseLockStatus }"
      pattern: "import.*computePhaseLockStatus.*from.*phase-lock"
    - from: "flowplan/src/hooks/use-phase-lock-status.ts"
      to: "flowplan/src/hooks/use-phases.ts"
      via: "usePhases(projectId) call inside hook"
      pattern: "usePhases\\(projectId\\)"
    - from: "flowplan/src/hooks/use-phase-lock-status.ts"
      to: "flowplan/src/hooks/use-tasks.ts"
      via: "useTasks(projectId) call inside hook"
      pattern: "useTasks\\(projectId\\)"
    - from: "flowplan/src/hooks/use-phase-lock-status.ts"
      to: "useMemo"
      via: "useMemo recomputes lock status when phases or tasks change"
      pattern: "useMemo\\(.*\\[phases.*tasks\\]"
---

<objective>
Build the phase lock service and React hook that determine which project phases are locked and which are unlocked, based on task completion in preceding phases.

Purpose: This is the foundation for the entire phase dependency feature. Without correct lock status computation and reactive updates, Phase 2 (UI enforcement) and Phase 3 (notifications) have nothing to build on.

Output: A pure `computePhaseLockStatus()` function with full TDD test coverage, plus a `usePhaseLockStatus()` React hook that automatically recomputes when tasks change via the existing TanStack Query invalidation chain.
</objective>

<execution_context>
@C:/Users/User/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/User/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-phase-lock-logic/01-RESEARCH.md

@flowplan/src/types/entities.ts
@flowplan/src/hooks/use-phases.ts
@flowplan/src/hooks/use-tasks.ts
@flowplan/src/services/phases.ts
@flowplan/src/services/tasks.ts
@flowplan/src/hooks/use-phases.test.ts
@flowplan/src/hooks/use-tasks.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD the phase lock service (pure function)</name>
  <files>
    flowplan/src/types/entities.ts
    flowplan/src/services/phase-lock.ts
    flowplan/src/services/phase-lock.test.ts
  </files>
  <action>
**Step 1 -- Add PhaseLockInfo to entities.ts:**

Add the `PhaseLockInfo` interface to `flowplan/src/types/entities.ts` in a new section after the "Computed/Derived Types" section (around line 272). Do NOT modify any existing types.

```typescript
// ============================================
// Phase Lock Types
// ============================================

export interface PhaseLockInfo {
  phaseId: string
  isLocked: boolean
  reason: 'first_phase' | 'previous_phase_complete' | 'previous_phase_incomplete'
  blockedByPhaseId: string | null
  blockedByPhaseName: string | null
}
```

**Step 2 -- RED: Write failing tests first in `phase-lock.test.ts`:**

Create `flowplan/src/services/phase-lock.test.ts`. Import from `./phase-lock` (file does not exist yet -- this is intentional TDD).

Use factory helpers matching the existing codebase pattern (see `scheduling.test.ts` for reference). Create `makePhase()` and `makeTask()` factories with all required `ProjectPhase` and `Task` fields plus `...overrides` spread. Use fixed dates like `new Date('2026-01-01')` for `created_at`.

Write these test cases in a `describe('computePhaseLockStatus')` block:

1. `'returns empty map for no phases'` -- empty arrays in, empty Map out
2. `'first phase is always unlocked'` -- single phase, no tasks, expect `isLocked: false` and `reason: 'first_phase'`
3. `'second phase locked when first has incomplete tasks'` -- 2 phases, task in phase 1 with `status: 'pending'`, expect phase 2 `isLocked: true` and `blockedByPhaseId` set to phase 1's ID
4. `'second phase locked when first has mixed task statuses'` -- 2 phases, one task `done` and one `in_progress` in phase 1, expect phase 2 locked
5. `'second phase unlocked when all tasks in first phase are done'` -- 2 phases, all tasks in phase 1 `status: 'done'`, expect phase 2 `isLocked: false`
6. `'empty phase does not block next phase'` -- 2 phases, phase 1 has zero tasks, expect phase 2 unlocked
7. `'handles non-contiguous phase_order values'` -- phases with orders 1, 5, 10 (gaps), verify correct lock cascading
8. `'tasks with null phase_id are ignored'` -- orphan task with `phase_id: null`, should not affect any phase's lock status
9. `'chain of three phases with proper cascading'` -- 3 phases: phase 1 done, phase 2 has pending task, phase 3 should be locked (blocked by phase 2, not phase 1)
10. `'single phase project is always unlocked'` -- one phase only, always unlocked regardless of task state
11. `'phases sorted correctly regardless of input order'` -- pass phases in reverse order, verify same result as sorted order

Also write a `describe('isPhaseLocked')` block with:
1. `'returns true for locked phase'`
2. `'returns false for unlocked phase'`
3. `'returns false for unknown phase id'`

Run tests: `cd flowplan && npx vitest run src/services/phase-lock.test.ts`. They MUST fail (module not found). Commit: `test(01-01): add failing tests for phase lock service`

**Step 3 -- GREEN: Implement `phase-lock.ts` to pass all tests:**

Create `flowplan/src/services/phase-lock.ts` with:

- Export `PhaseLockInfo` type (re-exported from entities.ts)
- Export `computePhaseLockStatus(phases: ProjectPhase[], tasks: Task[]): Map<string, PhaseLockInfo>`
  - Sort phases by `phase_order` ascending using `[...phases].sort()` (do NOT mutate input)
  - Return empty Map for empty phases array
  - First phase (index 0) always gets `isLocked: false, reason: 'first_phase'`
  - For each subsequent phase: filter tasks by `phase_id === previousPhase.id`, check if all are `status === 'done'`. Empty task list = complete (non-blocking). Use `tasks.filter(t => t.phase_id === previousPhase.id)` then `.every(t => t.status === 'done')`
  - Set `blockedByPhaseId` and `blockedByPhaseName` when locked
- Export `isPhaseLocked(phaseId: string, phases: ProjectPhase[], tasks: Task[]): boolean`
  - Calls `computePhaseLockStatus` and returns the `isLocked` value, defaulting to `false` for unknown IDs

Run tests: `cd flowplan && npx vitest run src/services/phase-lock.test.ts`. ALL must pass. Commit: `feat(01-01): implement phase lock service`

**Step 4 -- REFACTOR (if needed):**

Review the implementation for clarity. The function should be under 50 lines. If any refactoring is done, re-run tests to confirm they still pass. Commit only if changes were made: `refactor(01-01): clean up phase lock service`
  </action>
  <verify>
Run `cd flowplan && npx vitest run src/services/phase-lock.test.ts` -- all 14 tests pass.
Run `cd flowplan && npx vitest run src/services/phase-lock.test.ts --coverage` -- coverage for `phase-lock.ts` is 100% (all branches, lines, functions).
  </verify>
  <done>
`computePhaseLockStatus()` correctly computes lock status for all edge cases: empty phases, single phase, multi-phase cascading, non-contiguous phase_order, null phase_id tasks, and mixed task statuses. `isPhaseLocked()` convenience function works. All tests pass with 100% coverage on the service file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create usePhaseLockStatus React hook with tests</name>
  <files>
    flowplan/src/hooks/use-phase-lock-status.ts
    flowplan/src/hooks/use-phase-lock-status.test.ts
  </files>
  <action>
**Step 1 -- Create `use-phase-lock-status.ts`:**

Create `flowplan/src/hooks/use-phase-lock-status.ts` following the existing hook pattern from `use-phases.ts` and `use-tasks.ts`.

```typescript
import { useMemo } from 'react'
import { usePhases } from '@/hooks/use-phases'
import { useTasks } from '@/hooks/use-tasks'
import { computePhaseLockStatus } from '@/services/phase-lock'
import type { PhaseLockInfo } from '@/types/entities'

export function usePhaseLockStatus(projectId: string) {
  const { data: phases = [], isLoading: isLoadingPhases } = usePhases(projectId)
  const { data: tasks = [], isLoading: isLoadingTasks } = useTasks(projectId)

  const lockStatus = useMemo(() => {
    if (phases.length === 0) return new Map<string, PhaseLockInfo>()
    return computePhaseLockStatus(phases, tasks)
  }, [phases, tasks])

  return {
    lockStatus,
    isLoading: isLoadingPhases || isLoadingTasks,
    /** Check if a specific phase is locked */
    isLocked: (phaseId: string) => lockStatus.get(phaseId)?.isLocked ?? false,
    /** Get full lock info for a phase */
    getLockInfo: (phaseId: string) => lockStatus.get(phaseId) ?? null,
  }
}
```

This hook:
- Consumes `usePhases(projectId)` and `useTasks(projectId)` -- both already fetched in `page.tsx`, so TanStack Query will share the cache (no duplicate requests)
- Derives lock status via `useMemo` keyed on `[phases, tasks]`
- Automatically recomputes when `useUpdateTask.onSuccess` invalidates `taskKeys.lists()` and `phaseKeys.lists()` (existing reactivity chain -- no additional wiring needed)
- Exposes convenience methods `isLocked(phaseId)` and `getLockInfo(phaseId)`

**Step 2 -- Create `use-phase-lock-status.test.ts`:**

Create `flowplan/src/hooks/use-phase-lock-status.test.ts` following the existing hook test pattern from `use-phases.test.ts`.

Mock setup:
- `vi.mock('@/lib/supabase', () => ({ supabase: {} }))` -- required by service imports
- `vi.mock('@/services/phases')` -- mock `getPhases`
- `vi.mock('@/services/tasks')` -- mock `getTasks`

Use the `createWrapper` pattern with `QueryClient` + `QueryClientProvider` (see `use-phases.test.ts` for exact pattern). Create a fresh `QueryClient` with `{ defaultOptions: { queries: { retry: false } } }` to avoid test timeouts.

Use `makePhase()` and `makeTask()` factory helpers (same pattern as Task 1).

Write these test cases in a `describe('usePhaseLockStatus')` block:

1. `'returns loading state initially'` -- render hook, check `isLoading` is true before data resolves
2. `'returns lock status after data loads'` -- mock 2 phases (phase 1 done, phase 2 pending tasks), verify `isLocked('p2')` returns false (since phase 1 is complete)
3. `'isLocked returns true for locked phase'` -- mock 2 phases where phase 1 has incomplete tasks, verify `result.current.isLocked('p2')` is true
4. `'isLocked returns false for first phase'` -- verify first phase is never locked
5. `'getLockInfo returns null for unknown phase'` -- verify `getLockInfo('nonexistent')` returns null
6. `'returns empty map when no phases exist'` -- mock empty phases array, verify `lockStatus.size` is 0

Run tests: `cd flowplan && npx vitest run src/hooks/use-phase-lock-status.test.ts`. ALL must pass.

**Step 3 -- Run full test suite to verify no regressions:**

Run `cd flowplan && npx vitest run` to ensure no existing tests are broken by the new code. The new files should not affect any existing functionality since they are purely additive (new files, no modifications to existing service/hook files, only an interface addition to entities.ts).
  </action>
  <verify>
Run `cd flowplan && npx vitest run src/hooks/use-phase-lock-status.test.ts` -- all 6 hook tests pass.
Run `cd flowplan && npx vitest run src/services/phase-lock.test.ts` -- all 14 service tests still pass.
Run `cd flowplan && npx vitest run` -- full test suite passes with no regressions.
Run `cd flowplan && npm run build` -- TypeScript compilation succeeds (no type errors from new PhaseLockInfo interface or imports).
  </verify>
  <done>
`usePhaseLockStatus(projectId)` hook correctly derives lock status from `usePhases` + `useTasks` data via `useMemo`. The hook shares existing TanStack Query cache (no duplicate fetches). Reactivity is automatic: when `useUpdateTask.onSuccess` invalidates task and phase queries, the hook recomputes. All hook tests pass. Full test suite has no regressions. Build succeeds.
  </done>
</task>

</tasks>

<verification>
Phase 1 verification checklist:

1. **PDEP-01 (lock status determination):** `computePhaseLockStatus()` returns `isLocked: true` when any task in the previous phase is not 'done'. Verified by service tests (cases 3, 4, 9).

2. **PDEP-02 (first phase always unlocked):** First phase always gets `reason: 'first_phase'` and `isLocked: false`. Verified by service tests (cases 2, 10).

3. **PDEP-05 (auto-unlock on task completion):** The existing `useUpdateTask.onSuccess` invalidation chain triggers `usePhases` and `useTasks` re-fetch, which triggers `useMemo` recomputation in `usePhaseLockStatus`. No new wiring needed -- verified by confirming the hook uses `useMemo([phases, tasks])` dependency array. Verified indirectly by hook tests (cases 2, 3).

4. **Edge cases covered:** Empty phases (non-blocking), null phase_id tasks (ignored), non-contiguous phase_order (index-based iteration), mixed statuses (any non-done blocks), chain cascading (3+ phases).

Run these commands to verify the full phase:
```bash
cd flowplan && npx vitest run src/services/phase-lock.test.ts
cd flowplan && npx vitest run src/hooks/use-phase-lock-status.test.ts
cd flowplan && npx vitest run
cd flowplan && npm run build
```
</verification>

<success_criteria>
- All 14 service tests pass with 100% coverage on phase-lock.ts
- All 6 hook tests pass
- Full test suite passes (no regressions)
- TypeScript build succeeds
- `computePhaseLockStatus()` handles all 9 edge cases from research
- `usePhaseLockStatus()` hook automatically recomputes via existing TanStack Query invalidation chain
- No new npm dependencies added
- No existing files modified (except adding PhaseLockInfo interface to entities.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/01-phase-lock-logic/01-01-SUMMARY.md`
</output>
